<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Knight Roguelike</title>
  <style>
    html, body { height:100%; margin:0; background:#0b0b10; }
    canvas { display:block; margin:auto; background:#141424; touch-action:none; }

    /* simple on-screen joystick */
    .hud {
      position: fixed; inset: 0; pointer-events: none;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial;
      color: rgba(255,255,255,.85);
    }
    .tip { position: fixed; top: 12px; left: 12px; font-size: 13px; opacity:.8; }
    .joy {
      position: fixed; left: 18px; bottom: 18px;
      width: 140px; height: 140px;
      border-radius: 999px;
      background: rgba(255,255,255,.06);
      border: 1px solid rgba(255,255,255,.10);
      pointer-events: auto;
    }
    .knob {
      position:absolute; left:50%; top:50%;
      width: 56px; height: 56px;
      margin-left:-28px; margin-top:-28px;
      border-radius: 999px;
      background: rgba(255,255,255,.14);
      border: 1px solid rgba(255,255,255,.18);
      transform: translate(0,0);
    }
  </style>
</head>
<body>
  <canvas id="game" width="960" height="540"></canvas>

  <div class="hud">
    <div class="tip">WASD/ZQSD/IJKL/Pfeile: bewegen (auch diagonal) • Leertaste/Klick: Angriff • Shift/Rechtsklick: Dash (I-Frames) • Handy: Joystick links</div>
    <div class="joy" id="joy"><div class="knob" id="knob"></div></div>
  </div>

  <script>
    const canvas = document.getElementById("game");
    const ctx = canvas.getContext("2d");

    const VIEW = { w: canvas.width, h: canvas.height };
    const player = {
      x: VIEW.w/2,
      y: VIEW.h/2,
      r: 16,
      speed: 240,
      facingX: 1,
      facingY: 0,
      attackTimer: 0,
      attackCooldown: 0,
      dashTimer: 0,
      dashCooldown: 0,
      iframeTimer: 0,
      dashDirX: 1,
      dashDirY: 0,
      trail: []
    };

    const ATTACK_DURATION = 0.15;
    const ATTACK_COOLDOWN = 0.25;
    const ATTACK_RANGE = 74;
    const ATTACK_ANGLE = Math.PI * 0.8; // 144° cone
    const DASH_DURATION = 0.14;
    const DASH_COOLDOWN = 0.85;
    const DASH_SPEED = 760;
    const IFRAME_DURATION = 0.22;
    const MAX_TRAIL_POINTS = 8;

    const ENEMY_SPAWN_DELAY = 1;
    const ENEMY_SPAWN_INTERVAL = 3;
    const ENEMY_RADIUS = 14;
    const ENEMY_SPEED = player.speed * 0.5;
    const enemies = [];
    let enemySpawnTimer = ENEMY_SPAWN_DELAY;

    // Keyboard input (QWERTY + AZERTY + IJKL + arrow keys)
    const key = { left:false, right:false, up:false, down:false };
    const isLeftKey = (k) => k === "a" || k === "q" || k === "j" || k === "arrowleft";
    const isRightKey = (k) => k === "d" || k === "l" || k === "arrowright";
    const isUpKey = (k) => k === "w" || k === "z" || k === "i" || k === "arrowup";
    const isDownKey = (k) => k === "s" || k === "k" || k === "arrowdown";

    window.addEventListener("keydown", (e) => {
      const k = e.key.toLowerCase();
      if (isLeftKey(k)) key.left = true;
      if (isRightKey(k)) key.right = true;
      if (isUpKey(k)) key.up = true;
      if (isDownKey(k)) key.down = true;
    });
    window.addEventListener("keyup", (e) => {
      const k = e.key.toLowerCase();
      if (isLeftKey(k)) key.left = false;
      if (isRightKey(k)) key.right = false;
      if (isUpKey(k)) key.up = false;
      if (isDownKey(k)) key.down = false;
    });

    function tryAttack() {
      if (player.attackCooldown > 0) return;

      player.attackCooldown = ATTACK_COOLDOWN;
      player.attackTimer = ATTACK_DURATION;

      const dirLen = Math.hypot(player.facingX, player.facingY) || 1;
      const fx = player.facingX / dirLen;
      const fy = player.facingY / dirLen;
      const maxDist = ATTACK_RANGE + 16;

      for (let i = enemies.length - 1; i >= 0; i -= 1) {
        const enemy = enemies[i];

        const dx = enemy.x - player.x;
        const dy = enemy.y - player.y;
        const dist = Math.hypot(dx, dy);
        if (dist > maxDist + enemy.r || dist < 1) continue;

        const nx = dx / dist;
        const ny = dy / dist;
        const dot = nx * fx + ny * fy;
        const angleToTarget = Math.acos(Math.max(-1, Math.min(1, dot)));

        if (angleToTarget <= ATTACK_ANGLE * 0.5 && dist <= ATTACK_RANGE + enemy.r) {
          enemies.splice(i, 1);
        }
      }
    }

    function spawnEnemy() {
      const padding = ENEMY_RADIUS + 8;
      enemies.push({
        x: padding + Math.random() * (VIEW.w - padding * 2),
        y: padding + Math.random() * (VIEW.h - padding * 2),
        r: ENEMY_RADIUS
      });
    }

    function tryDash() {
      if (player.dashCooldown > 0 || player.dashTimer > 0) return;

      const dirLen = Math.hypot(player.facingX, player.facingY) || 1;
      player.dashDirX = player.facingX / dirLen;
      player.dashDirY = player.facingY / dirLen;
      player.dashTimer = DASH_DURATION;
      player.dashCooldown = DASH_COOLDOWN;
      player.iframeTimer = IFRAME_DURATION;
      player.trail.length = 0;
    }

    window.addEventListener("keydown", (e) => {
      if (e.code === "Space") {
        e.preventDefault();
        tryAttack();
      }
      if (e.code === "ShiftLeft" || e.code === "ShiftRight") {
        e.preventDefault();
        tryDash();
      }
    });
    canvas.addEventListener("pointerdown", () => tryAttack());
    canvas.addEventListener("contextmenu", (e) => {
      e.preventDefault();
      tryDash();
    });

    // Touch joystick
    const joy = document.getElementById("joy");
    const knob = document.getElementById("knob");
    let joyActive = false;
    let joyCenter = { x: 0, y: 0 };
    let joyVec = { x: 0, y: 0 }; // -1..1
    const JOY_RADIUS = 52;

    function setKnob(dx, dy) {
      knob.style.transform = `translate(${dx}px, ${dy}px)`;
    }

    function startJoy(ev) {
      joyActive = true;
      const r = joy.getBoundingClientRect();
      joyCenter.x = r.left + r.width/2;
      joyCenter.y = r.top + r.height/2;
      moveJoy(ev);
    }
    function endJoy() {
      joyActive = false;
      joyVec.x = 0; joyVec.y = 0;
      setKnob(0,0);
    }
    function moveJoy(ev) {
      if (!joyActive) return;
      const t = ev.touches ? ev.touches[0] : ev;
      let dx = t.clientX - joyCenter.x;
      let dy = t.clientY - joyCenter.y;
      const len = Math.hypot(dx, dy) || 1;
      const clamped = Math.min(JOY_RADIUS, len);
      dx = dx / len * clamped;
      dy = dy / len * clamped;
      setKnob(dx, dy);
      joyVec.x = dx / JOY_RADIUS;
      joyVec.y = dy / JOY_RADIUS;
    }

    joy.addEventListener("pointerdown", (e) => { e.preventDefault(); startJoy(e); });
    window.addEventListener("pointermove", (e) => { if (joyActive) moveJoy(e); });
    window.addEventListener("pointerup", endJoy);
    window.addEventListener("pointercancel", endJoy);

    // Game loop
    let last = performance.now();
    function loop(now) {
      const dt = Math.min(0.05, (now - last) / 1000);
      last = now;

      // combine keyboard + joystick
      let ix = (key.right ? 1 : 0) - (key.left ? 1 : 0) + joyVec.x;
      let iy = (key.down ? 1 : 0) - (key.up ? 1 : 0) + joyVec.y;

      const len = Math.hypot(ix, iy);
      if (len > 1) { ix /= len; iy /= len; }

      if (len > 0.01) {
        player.facingX = ix;
        player.facingY = iy;
      }

      player.attackTimer = Math.max(0, player.attackTimer - dt);
      player.attackCooldown = Math.max(0, player.attackCooldown - dt);
      player.dashTimer = Math.max(0, player.dashTimer - dt);
      player.dashCooldown = Math.max(0, player.dashCooldown - dt);
      player.iframeTimer = Math.max(0, player.iframeTimer - dt);

      enemySpawnTimer -= dt;
      while (enemySpawnTimer <= 0) {
        spawnEnemy();
        enemySpawnTimer += ENEMY_SPAWN_INTERVAL;
      }

      if (player.dashTimer > 0) {
        player.trail.push({ x: player.x, y: player.y, life: 0.22 });
        if (player.trail.length > MAX_TRAIL_POINTS) player.trail.shift();

        player.x += player.dashDirX * DASH_SPEED * dt;
        player.y += player.dashDirY * DASH_SPEED * dt;
      } else {
        player.x += ix * player.speed * dt;
        player.y += iy * player.speed * dt;
      }

      for (let i = player.trail.length - 1; i >= 0; i -= 1) {
        player.trail[i].life -= dt;
        if (player.trail[i].life <= 0) player.trail.splice(i, 1);
      }

      // clamp
      player.x = Math.max(player.r, Math.min(VIEW.w - player.r, player.x));
      player.y = Math.max(player.r, Math.min(VIEW.h - player.r, player.y));

      for (const enemy of enemies) {
        const awayX = enemy.x - player.x;
        const awayY = enemy.y - player.y;
        const awayLen = Math.hypot(awayX, awayY) || 1;
        enemy.x += (awayX / awayLen) * ENEMY_SPEED * dt;
        enemy.y += (awayY / awayLen) * ENEMY_SPEED * dt;

        enemy.x = Math.max(enemy.r, Math.min(VIEW.w - enemy.r, enemy.x));
        enemy.y = Math.max(enemy.r, Math.min(VIEW.h - enemy.r, enemy.y));
      }

      // render
      ctx.clearRect(0,0,VIEW.w,VIEW.h);
      ctx.fillStyle = "#141424";
      ctx.fillRect(0,0,VIEW.w,VIEW.h);

      // enemies
      for (const enemy of enemies) {
        ctx.fillStyle = "#ff8da1";
        ctx.beginPath();
        ctx.arc(enemy.x, enemy.y, enemy.r, 0, Math.PI * 2);
        ctx.fill();

        ctx.strokeStyle = "rgba(255,180,195,.7)";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(enemy.x, enemy.y, enemy.r + 3, 0, Math.PI * 2);
        ctx.stroke();
      }

      // player (knight placeholder)
      const invulnerable = player.iframeTimer > 0;
      ctx.fillStyle = invulnerable ? "#ffe59f" : "#ffd1dc";

      for (const ghost of player.trail) {
        const alpha = Math.max(0, ghost.life / 0.22) * 0.4;
        ctx.fillStyle = `rgba(255, 245, 185, ${alpha})`;
        ctx.beginPath();
        ctx.arc(ghost.x, ghost.y, player.r * 0.95, 0, Math.PI * 2);
        ctx.fill();
      }

      ctx.beginPath();
      ctx.arc(player.x, player.y, player.r, 0, Math.PI*2);
      ctx.fill();

      if (invulnerable) {
        const pulse = 1 + Math.sin(now * 0.03) * 0.15;
        ctx.strokeStyle = "rgba(255, 235, 140, 0.9)";
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.arc(player.x, player.y, (player.r + 7) * pulse, 0, Math.PI * 2);
        ctx.stroke();
      }

      // small "sword" direction hint
      ctx.strokeStyle = "rgba(255,255,255,.75)";
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(player.x, player.y);
      ctx.lineTo(player.x + player.facingX*24, player.y + player.facingY*24);
      ctx.stroke();

      // sword swing visualization
      if (player.attackTimer > 0) {
        const t = player.attackTimer / ATTACK_DURATION;
        const phase = 1 - t;
        const facingAngle = Math.atan2(player.facingY, player.facingX);
        const sweepStart = facingAngle - ATTACK_ANGLE * 0.5 + phase * (ATTACK_ANGLE * 0.5);
        const sweepEnd = facingAngle + ATTACK_ANGLE * 0.5 - (1 - phase) * (ATTACK_ANGLE * 0.5);

        ctx.strokeStyle = "rgba(255, 235, 150, 0.95)";
        ctx.lineWidth = 6;
        ctx.beginPath();
        ctx.arc(player.x, player.y, ATTACK_RANGE, sweepStart, sweepEnd);
        ctx.stroke();
      }

      requestAnimationFrame(loop);
    }
    requestAnimationFrame(loop);
  </script>
</body>
</html>
